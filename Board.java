/*
 * dr cameron's code: cameron/csci/CS448/MecGame
 */
package othellonator;

import java.util.* ;


public class Board {
    
    private static final int[] ADJACENT_ADDERS = {-11, -10, -9, -1, 1, 9, 10, 11} ; //increments for scanning radials from a position
    private static final int TOTAL_SQUARES = 64 ;
    
    private int myColor ; //computer player's color, ie othellonator's color
    private int[] positions = new int[100]; //the board
    private LinkedList<Move> legalMovesList = new LinkedList() ; //list of legal moves generated by generateLegalMoves()
    private Stack<Move> moveStack = new Stack<Move>() ; //stack to keep track of moves for recursive searches
    private int moveCount = 0;
    
    //data for use in returning threaded search
    private float heuristicValue ; 
    private int moveID ;
    
    //debugging
    public static int popCount = 0;
    public static int pushCount = 0;
    
    
    public Board (int color) {
         // initialize board with starting positions
        
        myColor = color ;
        
        //the 4 starting positions in the middle
        this.positions[44] = 1 ;  
        this.positions[55] = 1 ;
        this.positions[54] = -1 ;
        this.positions[45] = -1 ;
        
        //-2s around the borders
        for (int i = 0 ; i < 11 ; i++) {
            this.positions[i] = -2 ;
        }
        for (int i = 90 ; i < 100 ; i++) {
            this.positions[i] = -2 ;
        }
        for (int i = 10 ; i < 90 ; i += 10) {
            this.positions[i] = -2 ;
        }
        for (int i = 19 ; i < 99 ; i += 10) {
            this.positions[i] = -2 ;
        }
    }
    
    public Board (Board board) {
        myColor = board.myColor ;
        heuristicValue = board.heuristicValue ;
        
        int[] pos = new int[100];
        pos = board.positions.clone() ;
        positions = pos ;
        
        LinkedList<Move> lms = new LinkedList<Move>() ;
        lms = (LinkedList<Move>) board.legalMovesList.clone() ;
        legalMovesList = lms ;
        
        Stack<Move> ms = new Stack<Move>() ;
        ms = (Stack<Move>) board.moveStack.clone() ;
        moveStack = ms ;
    }
    
    public boolean generateLegalMoves (int color) {
        //loops through valid board positions and calls generateMoveForPosition() if 0 at index
        //adds valid moves to legalMovesList 
        //returns true if found at least one legal move, otherwise false
        //separate for loops are there to prevent evaluating squares that can't possibly ever be moves

        this.clearLegalMovesList() ;
        
        for (int positionsIndex = 11 ; positionsIndex < 19 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 21 ; positionsIndex < 29 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 31 ; positionsIndex < 39 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 41 ; positionsIndex < 44 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 46 ; positionsIndex < 49 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 51 ; positionsIndex < 54 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 56 ; positionsIndex < 59 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 61 ; positionsIndex < 69 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 71 ; positionsIndex < 79 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        for (int positionsIndex = 81 ; positionsIndex < 89 ; positionsIndex++ ) {
            switch (this.positions[positionsIndex]) {
                case 0 : 
                    generateMoveForPosition(color, positionsIndex) ;
                    break;
            }
        }
        //return true if found at least one legal move, otherwise false
        switch (this.legalMovesList.size()) {
            case 0 : return false ;
            default : return true ;
        }
        
        
    }
    
    public void applyMove (int color, Move move) {
        //applies move based on fields of supplied move and pushes it to the stack
        if (move.getPosition() == -1) {
            //move is pass
        } 
        else {
            this.positions[move.getPosition()] = color;
            Stack<Integer> flipStack = move.getFlips();
            int amountOfFlips = flipStack.size();
            for (int i = 0; i < amountOfFlips; i++) {
                this.positions[flipStack.pop()] = color;
            }
        }
        this.pushMoveToHistory(move) ;
        this.clearLegalMovesList() ;
        
        //debugging stuff
        pushCount++;
        //System.out.println("push");
        //this.printBoard();
    }
    
    public void revertMove() {
        //pops a move from the stack and reverses it
        try {
            Move move = this.popMoveFromHistory(); //pop a move off the stack
            if (move.getPosition() == -1) {
                //move is pass
            } 
            else {
                this.positions[move.getPosition()] = 0; //set move position to empty

                int stackSize = move.getFlipStackSize(); //how many flips are there?
                for (int i = 0; i < stackSize; i++) { //loop through the stack
                    int flipPosition = move.popFlip();
                    //System.out.println(flipPosition);
                    this.setPosition(flipPosition); //pop a flip and un-flip it
                }

            }

            //Debugging stuff
            popCount++;
            //System.out.println("pop");
            //this.printBoard();

        } catch (NullPointerException e) {
            System.out.println("(C you tried to pop an empty move stack )");
        }
    }
    
    
    private void generateMoveForPosition (int color, int position) {
        
        Stack<Integer> flipStack = new Stack<Integer>() ; //list of all flips found for position
        int pointer ; //pointer to position that is currently being evaluated
        
        //loop through each possible line radiating from position
        for (int i = 0 ; i < ADJACENT_ADDERS.length ; i++ ) {
            Stack<Integer> lineStack = new Stack<Integer>() ; //list of flips found on individual radial
            pointer = position + ADJACENT_ADDERS[i] ;  
            boolean foundSameColor = false ;           
            
            //loop through each position in the line
            //end loop if same color, edge, or empty space found
            boolean loop = true ;
            while (loop) {
                int stateAtPointer = this.positions[pointer] ;
                switch (stateAtPointer) {
                    case 0 : loop = false ; break; //found empty
                    case -2 : loop = false ; break; //found edge
                    default :
                        int colorEvaluate = color * stateAtPointer ;
                        switch (colorEvaluate) {
                            case 1 : //found same color
                                foundSameColor = true ; 
                                loop = false ; 
                                break;
                            case -1 :  //found opposite color   
                                lineStack.push(pointer) ;  
                                pointer += ADJACENT_ADDERS[i] ;
                                break;
                        } break;
                }
            }
            if (foundSameColor && lineStack.size() > 0) {
                flipStack.addAll(lineStack); //join lineStack with flipStack if flips found along current radial
            }
        }
        //push the move on to legalMovesList if valid flips found.  otherwise do nothing.
        switch (flipStack.size()) {
            case 0 : 
                break;//do nothing
            default : 
                this.legalMovesList.push(new Move(position, flipStack)) ;
                break ;
            
        }

          
    }
    
    public boolean evaluateOpponentMove (int color, int position) {
        //runs generateMoveForPosition() to generate flips and push the move on to the list
        //then applies the move at the front of the list
        boolean legal = false ;
        Move move = null ;
        
        this.generateLegalMoves(myColor * -1);  //evaluate legal moves for opponent
        for (int i = 0 ; i < this.legalMovesList.size() ; i++) { //check move against legalMovesList
            Move tester = this.getLegalMove(i) ; 
            //if opponent's move found in legalMoveList, it is legal
            if (tester.getPosition() == position) {
                legal = true;
                move = tester ;
            }
        }
        //if the move is legal, apply it and return true.  otherwise return false.
        if (legal) {
            applyMove(color, move) ;
            return true ;
        }
        else return false ;
    }
    
    public int makeComputerMove (long timeRemaining) {
        //othellonator makes a move



        Move myMove = null;
        moveCount++;
        System.out.println("(C moveCount = " + moveCount + ")");
        if (this.generateLegalMoves(myColor)) { //evaluate board, do stuff if legal moves found
            String listSize = Integer.toString(getLegalMovesListSize()) ;
            System.out.println("(C Number of moves:" + listSize + " )");
                        
            if (moveCount < 10) {
                myMove = Search.alphaBetaSearch(this, 6, myColor) ;
            }
            else if (moveCount >= 10 && moveCount <= 20) {
                myMove = Search.alphaBetaSearch(this, 8, myColor) ;
            }
            else {
                myMove = Search.alphaBetaSearch(this, 10, myColor) ;
            }
            this.applyMove(myColor, myMove) ;  //apply the move returned by the search
            return myMove.getPosition() ; //return the position of the move so it can be output
        }
        else return -1 ; //signal that no move was found
        
        
    }
    
    
    
    public void printBoard() {
        System.out.println("(C     a b c d e f g h )");
        for (int lines = 1 ; lines < 9 ; lines++) {
            System.out.print("(C ") ;
            System.out.printf("%d| ", lines) ; //prints the row number
            for (int position = lines + 10 ; position < 90 ; position += 10 ) {
                int stateAtPosition = this.positions[position] ;
                char blackWhiteOrZero ;
                switch (stateAtPosition) {
                    case 1 : blackWhiteOrZero = 'W'; break;
                    case -1 : blackWhiteOrZero = 'B'; break;
                    default : blackWhiteOrZero = '-' ;
                }
                System.out.printf("%2c", blackWhiteOrZero) ; //prints value of each position (0, B, or W)
                
            }
            System.out.print(" )\n") ; //end of row
         }
     }
    
    public int getMyColor () {
        return this.myColor ;
    }
    
    public LinkedList<Move> getLegalMovesList () {
        return (LinkedList<Move>) this.legalMovesList.clone() ;
    }
    
    public Move getLegalMove (int i) {
        return legalMovesList.get(i).cloneMove() ;
    }
    
    public int getLegalMovesListSize () {
        int i = this.legalMovesList.size() ;
        return i ;
    }
    
    private void clearLegalMovesList () {
        this.legalMovesList.clear();
    }
    
    private void pushMoveToHistory (Move m) {
        this.moveStack.push(m) ;
    }
    
    private Move popMoveFromHistory () {
        Move m = this.moveStack.pop() ;
        return m ;
    }
    
    private void setPosition (int position, int color) {
        this.positions[position] = color ;
    }
    
    private void setPosition (int position) {
        int color = this.positions[position] ;
        this.positions[position] = color * -1 ;
    }
    
    public void setHeuristicValue (float val) {
        this.heuristicValue = val ;
    }
    
    public float getHeuristicValue () {
        return this.heuristicValue ;
    }
    
    public void setMoveID (int id) {
        this.moveID = id ;
    }
    
    public int getMoveID () {
        return this.moveID ;
    }
    
    public Move popMove () {
        Move move = this.moveStack.pop() ;
        return move ;
    }
    
    public boolean isTerminalNode (int color) {
        boolean opHasMoves = this.generateLegalMoves(color * 1) ;
        boolean iHaveMoves = this.generateLegalMoves(color) ;
        if (opHasMoves || iHaveMoves) return false ;
        else return true ;
    }
    
    public int countBlackPieces () {
        int count = 0 ;
        for (int i : this.positions) {
            switch (i) {
                case -1 : count++ ; break;
                default : break ;
            }
        }
        return count ;
    }

    public int countWhitePieces () {
        int count = 0 ;
        for (int i : this.positions) {
            switch (i) {
                case 1 : count++ ; break;
                default : break ;
            }
        }
        return count ;
    }
    
    public int[] countPieces () {
        int blackCount = 0;
        int whiteCount = 0;
        for (int i : this.positions) {
            switch (i) {
                case 1:
                    whiteCount++;
                    break;
                case -1 : 
                    blackCount++;
                    break;
                default:
                    break;
            }
        }
        int[] count = new int[2] ;
        count[0] = blackCount ;
        count[1] = whiteCount ;
        return count;
    }
    
    public float evaluate(int color) {
        color = myColor; //
        //insert super awesome evaluation function here
        final float MAX_MOBILITY = 14F;
        final float MY_CONTROL_COEFF = 0.6F ;
        final float MY_MOBILITY_COEFF = 0.4F ;
        final float OP_CONTROL_COEFF = 0.6F ;
        final float OP_MOBILITY_COEFF = 0.4F ;
        
        float myControl = 0;
        float opponentControl = 0;
        int[] counts = this.countPieces() ;
        switch (color) {
            case 1 :
                myControl = (float) counts[1] / TOTAL_SQUARES ;
                opponentControl = (float) counts[0] / TOTAL_SQUARES ;
                break;
            case -1 :
                myControl = (float) counts[0] / TOTAL_SQUARES ;
                opponentControl = (float) counts[1] / TOTAL_SQUARES ;
                break;
            default : 
                System.out.println("(C Something is horribly wrong. Trying to evaluate with no color specified.") ;
                break;
        }
        
        this.generateLegalMoves(color) ;
        float myMobility = ((float)this.legalMovesList.size()) / MAX_MOBILITY;
        this.generateLegalMoves(color * -1);
        float opponentMobility = ((float)this.legalMovesList.size()) / MAX_MOBILITY;
        
        if (this.isTerminalNode(color)) { //if terminal node
            if (myControl > opponentControl) return 1F;          //return 1 if i win
            else return -1F;     //or -1 if opponent wins
        }
        
        return (myControl * MY_CONTROL_COEFF) - (opponentControl * OP_CONTROL_COEFF)
                + (myMobility * MY_MOBILITY_COEFF) - (opponentMobility * OP_MOBILITY_COEFF) ;
    }
}
